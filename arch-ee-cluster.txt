Замечательная статья 2005-го года: Under the Hood of J2EE Clustering
http://www.theserverside.com/news/1364410/Under-the-Hood-of-J2EE-Clustering

Важно понимать, что кластер должен обеспечивать две вещи:
 - Балансировку нагрузки (Load Balancing)
 - Преодоление отказа (Failover)

Балансировка нагрузки: между вызываемым объектом и вызывающим субъектом должен находиться компонент - балансировщик
нагрузки, задача которого - перераспределять запросы между разными экземплярами вызываемого объекта. Высокая доступность
и высокая производительность реализуются именно данным способом.

Преодоление отказа: если целевой объект (т.е. тот, к которому перенаправляются вызовы) падает, то система преодоления
отказов должна зафиксировать данный факт и перенаправить последующие запросы на живые объекты. Именно данным способом
реализуется отказоустойчивость.

Чтобы понять кластеризацию нужно ответить на следующие вопросы:
 - Какие типы объектов могут быть кластеризованы?
 - Где осуществляется балансировка нагрузки и преодоление отказов в моем коде?

В реальности не каждый объект может быть кластеризован и не всегда в коде осуществляется балансировка нагрузки и
преодоление отказа.

Пример кода:

class A:

public class A {
    ...

    public void business() {
        B instance1 = new B();
        instance1.method1();
        instance2.method2();
        ...
    }
}

class B:

public class B {
    ...

    public void method1() {
    }

    public void method2() {
    }
}

В данном коде вызовы методов класса B из класса не обеспечивают ни балансировку нагрузки, ни преодоление отказа.
Для обеспечения данных параметров необходим интерцептор между вызывающим и вызываемым объектами, который будет
осуществлять диспетчеризацию и перенаправление запросов на различные объекты. Объекты классов A и B работают в одной
и той же JVM и сильносвязаны. Это очень сложно добавить логику диспетчеризации между ними.

Таким образом,
какие типы объектов могут быть кластеризованы? - Только те, которые могут быть развернуты на распределенной системе.
где реализуется балансировка нагрузки и преодоление отказов в коде? - Только при вызове методов удаленных объектов.

Кластеризация на веб-уровне (фундаментальная, базовая функция J2EE-кластеризации)
---------------------------------------------------------------------------------

Включает в себя:
 - Балансировку веб-нагрузки (Web Load Balancing)
 - Преодоление отказов HTTP Session (HTTPSession failover, репликация сессии)

Задачи балансировки:
 - реализация алгоритмов балансировки нагрузки (Round-Robin, Random, Weight based)
 - проверка доступности целевых серверов
 - привязка к сессии (session stickiness) - если сессия создана на сервере 1, то все запросы в рамках этой сессии 
   отправляются на сервер 1, пока он жив.


Задачи преодоления отказов сессии
Т.к. сессия обычно хранится в памяти машины, то при использовании session stickness все хорошо - запросы 
в рамках сессии перенаправляются на тот сервер, в памяти которого хранятся данные этой сессии. Однако при падении данного
сервера необходимо сделать так, чтобы данные сессии не пропали, а стали доступны на другом сервере, на который будут
перенаправлены запросы в рамках данной сессии.

Чтобы реализовать данное поведение необходимо обеспечить следующее:
 - Глобальный идентификатор сессии (что-бы не путать сессию, изначально созданную на одном сервере с сессиями на том сервере,
    на который будет выполнено перенаправление)
 - Решить каким образом обеспечить резервное копирование состояния сессии
   Механизмы резервного копирования состояния сессии - ключевой фактор, которыми отличаются разные сервера приложений   
 - Частота и гранулярность копирования (резервное копирование сессии - процесс требующий ресурсов процессора,
   сети и диска (при хранении сессии в БД), поэтому обеспечение данного процесса может сильно снижать производительность
   кластера (пишут, что JBoss в свое время гнал данные сессии по сети на все сервера кластера, а JSF, например, особенно
   в купе с кривыми руками очень любит Session Scoped данные, у Tomcat'а вполне возможно и сейчас так)).
                                                                    
Подходы к сохранению данных сессии:
 - Использование СУБД через JDBC (для сериализации объектов сессии может использоваться стандартный 
        механизм сериализации JVM)
   см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image014.gif

 - Репликация в памяти (гораздо быстрее сохранения в БД, реализована во многих серверах приложений, таких как
     Tomcat, JBoss, WebLogic, WebSphere)
   см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image016.gif
   Пишут, что в Tomcat и JBoss для репликации используют Java Groups.
   Данный способ требует привлечения части ресурсов процессора на управление репликацией, а так же может требовать
   серьезного увеличения объема ОЗУ на хранение данных сессии, что так же влияет на работу JVM GC.
   Интересно так же, что WebLogic определяет пару для репликации для каждой сессии, а не для каждого сервера

 - Подход IBM - централизованный сервер для хранения состояния. Вариация репликации в памяти, только все данные
   сессии со всех серверов участников кластера сохраняются в выделенном сервере хранения состояния.
   см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image022.gif

 - Подход SUN - специализированная СУБД - In Memory HA DB с доступом по JDBC.
   см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image024.gif

Вообще производительность - это большая проблема при обеспечении session failover. Поэтому обеспечивать репликацию
сессии в реальном времени невозможно. Очень важно выбрать правильный компромисс между доступностью данных и нагрузкой
(если реплицировать каждое изменение - то взрывной рост нагрузки, если же очень редко - после падения сервера часть
данных может быть потеряна).  Два распространенных подхода:
 - По веб-методу: данные сессии реплицируются в конце обработки каждого запроса перед отправкой ответа клиенту.
   Данный метод гарантирует, что данные сессии будут полностью обновлены.
 - По времени: задается постоянный интервал времени при истечении которого происходит резервное копирование сессии. Данный
   метод не дает гарантий по полному обновлению данных сессии, но увеличивает производительность, т.к. обновление происходит
   не после обработки каждого запроса.

Гранулярность резервного копирования:

 - Сессия целиком
 - Модифицированая сессия (вся сессия сохраняется, если ее состояние изменяется (вызываются методы session.setAttribute(),
     session.removeAttribute())). В приложении необходимо гарантировать, чтобы изменение данных сессии обеспечивалось
     ТОЛЬКО путем вызова данных методов.
 - Модифицированные атрибуты (сохраняются только модифицированные атрибуты сессии, что минимизирует объем данных,
     требующих сохранения. Однако, чтобы он работал нужно соблюдать условия: 1) использовать для модификации сессии
     только метод setAttribute(), 2) тщательно следить за отсутствием перекрестных сылок между атрибутами. Граф объектов
     для каждого атрибута сериализуется и сохраняется отдельно. Если же между двумя атрибутами есть перекрестные ссылки,
     то это может привести к ошибкам сериализации и десериализации, например могут быть потеряны связи между объектами. 
     Совет простой - нужно хранить как атрибут сессии только корневой объект и модифицировать по-сути можно только его).


Другие реализации failover:
 - JRun with Jini - distributed system services, object processing, sharing and migration
 - Tangosol Coherence (сейчас - Oracle Coherence) - распределенный кэш.

Реализация кластеризации JNDI
-----------------------------

В спецификации J2EE содержится требование, что все контейнеры должны предоставлять реализацию JNDI. Основное назначение
JNDI в J2EE - реализация уровня, связывающего между собой все ресурсы. Соответственно кластеризация JNDI очень важна,
т.к. например работа с каждым EJB начинается с поиска его интерфейса в JNDI дереве. Вендоры реализуют кластеризацию
JNDI по-разному в зависимости от структуры своих кластеров.

Разделяемое глобальное JNDI-дерево

WebLogic и JBoss содержат глобальное, распределяемое, JNDI контекст уровня кластера, который клиенты могут использовать
для поиска и получения объектов. Данный контекст реплицируется на все узлы кластера с помощью IP Multicast'а, таким образом
даже если экземпляр сервера упадет, то ресурсы все равно будут доступны. 

см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image028.gif

Реализуется так - на каждой ноде свое локальное хранилище JNDI. Изменения распространяются между хранилищами с помощью
IP Multicast, таким образом каждый локальный сервер имен содержит копию объектов каждого другого сервера имен в своем дереве.
Данная излишняя структура обеспечивает высокую доступность JNDI-дерева.

На практике такая структура может использоваться для двух моментов. Во-первых, для развертывания, что является задачей
администратора. После развертывания EJB-модуля или установки JDBC/JMS-ресурсов на одном экземпляре сервера,
все объекты в JNDI-дереве будут реплицированы на другие экземпляры. Во время исполнения, приложения могут использовать
JNDI-дерево для сохранения и извлечения объектов с использованием JNDI API и ваши кастомные объекты так же будут
глобально реплицированы.

Независимые JNDI

SUN, WebSphere и другие сервера приложений реализуют механизм независимого JNDI-дерева для каждого экземпляра сервера 
приложений. Участники такого кластера не знают о наличии или отсутствии других серверов в кластере. Однако, это не значит,
что им не нужно JNDI-дерево уровня кластера, т.к. поскольку работа с EJB начинается с его поиска в JNDI-дереве (я так понимаю,
для EJB 3, 3.1 это все еще актуально, просто поиск выполняется неявно), то возможности кластера нельзя использовать без
кластеризации JNDI.

Независимые JNDI реализуют высокую доступность только если их J2EE-приложения гомогенны. Гомогенность подразумевает,
что все участники кластера имеют одни и те же настройки и на них развернуты одни и те же приложения. При соблюдении
данных условий специальные инструменты администрирования, называемые агентами, помогают обеспечить высокую доступность.

см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image030.gif

И SUN JES и IBM WebSphere имеют агентов, установленных на каждой ноде. При разворачивании EJB или внесении других
изменений в JNDI-дерево, консоль администрирования посылает команды каждому агенту, что позволяет достигать того же
эффекта, что и использование глобального JNDI-дерева.

Но! Незавимое JNDI-дерево не поддерживает репликацию и высокую доступность объектов, которые связываются и извлекаются
запущенным приложением.  На это есть причина: основная роль JNDI в J2EE - обеспечивать уровень связи с администрируемыми 
объектами, а не являться репозиторием данных времени выполнения. Если же есть такие требования, то высокодоступный сервер
LDAP или СУБД могут помочь в их реализации. И IBM и SUN имеют собственные продукты LDAP-серверов, распротраняемые с
кластерными возможностями.

Централизованное JNDI

Некоторые сервера приложений используют централизованное JNDI - сервер имен хостится на одном экземпляре сервера и все
участники кластера регистрируют свои EJB и другие административные ресурсы на едином сервере имен.

Сервер имен самостоятельно реализует высокую даступность будучи прозрачным для клиентов. Все клиенты ищут EJB в данном
сервере имен. Однако данная структура усложняет установку и настройку  (а так же вводит единую точку отказа), поэтому
многие вендоры от нее отказываются.

Доступ к JNDI-серверу

Прежде чем начать работать с кластером приложение-клиент должно как-то понять, как ему достучаться до нужного сервера.
Реализуется доступ путем помещения балансировщика нагрузки между клиентом и кластером JNDI, однако нужно же знать
адрес куда стучаться. Разные вендоры реализуют разные подходы:

 - SUN JES, JBoss реализуют кластер JNDI путем указания в качестве значения параметра java.naming.provider.url
   списка URLей участников кластера, разделенных запятыми. Например, 
   java.naming.provider.url=server1:1100,server2:1100,server3:1100,server4:1100 Клиент будет пытаться получить доступ
   к каждому серверу в списке, перебирая их один за другим до тех пор, пока один из них не ответит.
   (это хорошо про failover, а как быть с балансировкой?)

 - JBoss так же реализует auto-discovery. Если строка "java.naming.provider.url" пустая, то клиент будет пытаться найти
   JNDI-сервер, рассылая мультикаст-запросы по сети.

Реализация кластеризации EJB
----------------------------

EJB - важная часть спецификации J2EE и кластеризация EJB - наиболее сложная проблема при реализации кластера J2EE.

Технология EJB вышла из распределенных вычислений. EJB могут работать на независимых серверах. Веб-сервисы или RICH-клиенты
могут получить доступ к EJB с других машин посредством стандартного протокола RMI/IIOP. Можно вызывать методы удаленных
EJB аналогично методам локальных Java-объектов. Фактически, RMI/IIOP маскирует тот факт, удаленный или локальный
объект вы вызываете. Это называется local/remote прозрачность.

см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image032.gif

Вызов EJB осуществляет через локальный объект-посредник - стаб. Стабы работают на клиентской JVM и знают как получить
доступ через сеть к реальным объетам посредством RMI/IIOP. 

Чтобы вызвать EJB в своем коде необходимо решить следующие задачи:
 - Запросить  EJBHome стаб из JNDI-дерева
 - Запросить или создать EJB-объект посредством  EJBHome стаба. Вернется стаб  EJBObject.
 - Осуществить вызов метода EJB посредством стаба  EJBObject.

Балансировка нагрузки и преодоление отказов реализуются на первом шаге. Во время вызовов методов EJB-стабов 
(включая EJBHome и EJBObject), вендоры реализуют балансировку нагрузки и преодоление отказов следующими тремя различными
способами.

Умный стаб (Smart stub)

Клиент осуществляет вызов EJB посредством объекта стаба. Данный стаб может быть извлечен из JNDI-дерева и если возможно,
то клиент может даже скачать class-файл стаба с любого веб-сервера прозрачно. Таким образом стаб реализует следующие
возможности:
 - может быть сгенерирован динамически и программно во время выполнения и определение стаба (class-файл) не обязательно
   должно находиться в classpath клиента или быть частью клиентской библиотеки (т.к. он может быть скачан).

см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image034.gif

WebLogic и JBoss реализуют кластеризацию EJB внедрением специфичного поведения в код стаба, который прозрачно работает
на клиентском уровне (код клиента при этом ничего не знает о данном коде). Данная техника называется "умный стаб".

Умный стаб реально умный, т.к. содержит список целевых экземпляров серверов, который он может вызвать. Он может определять
любые сбои на целевых экземплярах и содержит сложную логику балансировки нагрузки и преодоления отказов при диспетчеризации
запросов на целевые экземпляры. Так же если топология кластера изменяется, то стаб может обновить свой список целевых 
серверов, чтобы тот соответствовал топологии кластера без внесения каких либо изменений руками.

Данное решение обладает следующими примуществами:
 - Т.к. стаб работает на клиентской стороне, то он не требует затрат ресурсов сервера на балансировку и преодоление отказов;
 - Балансировка нагрузки внедрена в клиентский код и зависит от жизненного цикла клиента. Это устраняет единую точку
   отказов в лице балансировщика - каждый клиент является своим собственным балансировщиком.
 - Код стаба может быть скачан динамически и может обновлять себя при необходимости, что исключает необходимость
   ручного вмешательства (zero maintenance).

IIOP библиотека времени исполнения

SUN JES реализует кластеризацию EJB по-другому. Логика балансировки нагрузки и преодоления отказов реализована в
IIOP библиотеки времени исполнения. Например, JES содержит модифицированный класс ORBSocketFactory, чтобы позволить ему
быть уровня кластера. (библиотека IIOP расположена на стороне клиента)

см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image036.gif

Модифицированная версия ORBSocketFactory содержит всю логику балансировки нагрузки и преодоления отказов, что позволяет
самому стабу оставаться маленьким и чистым. Т.к. реализация сосредоточена в библиотеке времени исполнения, то она
может использоваться из многих стабов, что экономит ресурсы. Однако данная реализация требует наличия специфичной
библиотеки не клиентской стороне, что может вызвать проблемы с интероперабельностью с другими J2EE-продуктами.

Прокси-интерцептор (Interceptor Proxy)

IBM WebSphere использует Location Service Daemon (LSD), который работает как прокси-интерцептор для EJB-клиентов.

см. рис. http://media.techtarget.com/tss/static/articles/content/J2EEClustering/clip_image038.gif

При использовании данного решения клиент получает стаб с помощью JNDI. Стаб содержит информацию для роутинга к LSD,
а не к хосту, содержащему EJB. После того, как LSD получает входящий запрос, он определяет куда его отправить на обработку,
тем самым реализуя балансировку нагрузки и преодоление отказов. Данное решение требует дополнительных работ по установке
и настройке.

Важно! Кластеризация Statefull Session Beans похожа на кластеризацию HTTP Session. При нормальной работе EJBObject stub
не перенаправляет запросы на другие сервера при работе с Statefull Session Beans, вместо этого он привязывается к серверу,
на котором Statefull Session Bean был вызван изначально. Во время работы информация о сессии резервно копируется и становится
доступной другим участникам кластера. Если основной сервер падает, то другой резервный сервер начинает обслуживать вызовы
к statefull session bean.

Entity beans сами по себе stateless, однако они могут обслуживать statefull-запросы. Все изменения данных копируются в БД
с использованием встроенных механизмов Entity Beans. Таким образом для Entity Beans балансировка нагрузки и преодоление
отказов может быть реализована так же как и для Stateless Session Beans. Однако, де-факто для Entity Beans балансировка
нагрузки и преодоление отказов большую часть времени не задействуются. В зависимости от дезайн-паттерна, Entity Beans
оборачиваются в соотв. Session Beans фасад, таким образом связь между SB и EB локальная по Home-интерфейсу, а значит 
балансировка нагрузки и преодоление отказов не задействуются. 

Поддержка кластеризации JDBC и JMS ресурсов
-------------------------------------------

Для данных объектов кластеризация может как поддерживаться, так и не поддерживаться. 

В наше время некоторые продукты, такие как Oracle RAC поддерживают кластеризацию, однако JDBC - это сильносвязанный протокол,
который держит соединение с СУБД посредством сокетов долгое время и реализовать его кластеризацию очень тяжело.
Если JDBC-соединение умирает, то все JDBC-объекты, ассоциированные с данным соединением так же умирают. В клиентском
коде должно быть реализовано пересоединение. WebLogic используется мультипул JDBC для упрощения процесса переподключения
(я так понимаю это - Multi DataSource).

JMS поддерживается во многих J2EE серверах приложений, но не полностью. Балансировка нагрузки и преодоление отказов
реализованы только для JMS-брокера, и только некоторые продукты реализуют функцию преодоления отказов для сообщений,
находящихся в JMS Destination.

Мифы о J2EE кластеризации
-------------------------

  - Преодоление отказов может полностью избавить от ошибок. Нет!
    В принципе преодоление отказов даже не всегда нужно (пример - Amdocs со смартклиентом, которых хранит данные 
    сессии у себя, в таком случае не нужно реплицировать сессию, достаточно только балансировки нагрузки)
    Важно понимать, что преодоление отказов работает только между вызовами методов, если ошибка возникнет во время
    исполнения методов, то ее с помощью данной технологии не преодолеешь, нужны другие средства. Особенно это касается
    неидемпотентных методов. В серьезных приложениях очень важно сделать все методы идемпотнетными, для этого нужно
    использовать транзакции, проверки на существование, в случае участия нескольких систем - распределенные транзакции 
    и т.д. 

    Приводится пример интернет магазина, обслуживающего в момент сбоя 100 пользователей. Там такие соображения, мол нет
    преодоления отказов - в случае падения теряем все 100 сессий (а это могут быть уже заполненные корзины, если есть,
    то предположим 20% обрабатывали заказ, они и получат ошибку, остальные 80 ничего не заметят. Нужно считать следующее:
     - разницу между 20 пользователями, почувствовашими проблему и 100 пользователями
     - разницу в цене между обеспечением преодоления отказов и без такого обеспечения

  - Автономные приложения могут прозрачно быть преобразованы в работающие на кластере. Нет!
    Многие вендоры вещают о прозрачной кластеризации, однако в реальности необходимо подготовить приложение
    к работе на кластере. Нужно обеспечить: Http Session Replication (объекты в сессии должны быть сериализуемыми, 
    при сохранении в БД нужно стремиться, чтобы объем сессии не был очень большим, перекрестные ссылки - избегать), 
    распределенное кэширование (столкнулись в Naumen'е, когда не поддерживали JBoss Cache, потом прикрутили), 
    Статические переменные (тот же синглтон, который в кластерной среде не будет синглтоном), 
    доступ ко внешним ресурсам (например, распределенная ФС) и специальным сервисам (например, таймер)).

  - Распределенные структуры (Web и EJB уровни разделены и между ними есть балансировка) более гибки 
    чем установленные (collocated) (Web и EJB уровни на том же сервере, балансировка только от клиента до Web)
    - Скорее всего нет (Maybe not)
    Здесь интересное рассуждение о том, что если распределенные системы не быстрее коллокейшна, то зачем они нужны?
    Соображения следующие:
     - Слой EJB можно использовать не только для HTTP, но и для т.н. рич приложений, работающих напрямую с EJB.
     - EJB и Web-компоненты могут находится на разных уровнях безопасности, и должны быть физически разделены. Например,
       между веб- и EJB-уровнем можно использовать файрволл.
     - Сильная несимметричность между веб- и EJB-уровнями. Например есть очень сложные и требовательные к ресурсам EJB,
       которые могут работать только на очень мощных  серверах. С другой стороны, веб-слой очень простой, чтобы на него
       тратить дорогие сервера. Можно купить мощные сервера для EJB-слоя и гораздо менее мощные для веб. 

Выводы
------

Кластеризация очень сильно отличается от автономной работы. Различные вендоры серверов приложений используют разные подходы
к обеспечению кластеризации. Необходимо готовиться к использованию приложения на кластерном окружении с самого момента
начала работы над ним. Выберите правильный продукт, подходящий под ваши требования. Так же необходимо правильно
выбрать фреймворки, подходящие для кластеризации. 
